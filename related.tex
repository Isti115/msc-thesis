\chapter{Related Work}
\label{sec:related}

Since our goal is not the introduction of a new way to address the problem of creating correctness proofs for parallel programs, rather the adaptation of an existing system for formalized implementation, instead of discussing the theoretical methods, here we focus on a more practical approach and explore what others have achieved in the field of computer based verification.

\section{Previous works in Agda}
A very recent article \cite{Bergsten2017MethodsFU} presents a similar approach to ours, by setting out to provide an alternative to paper based proofs by formalizing an existing semi-formal model of concurrent programming. Their results provide methods for the confirmation of certain safety and liveness properties. Since it was the most closely related to what we have done, we compare their work to ours and discuss the similarities as well as the differences. The Agda programming language served as the meta-theory, in which the formalization and proofs were constructed for both projects, but the object-theory was different. We built our system around a language similar to UNITY, a language specifically created for and entirely based on parallelism for a book titled \textit{Parallel Program Design: A Foundation}\cite{misra1989foundation} (not to be confused with the modern game engine), that has essentially no guaranteed sequentiality, while their subject was an extension of the CPL language borrowed from \cite{owicki1982proving}, upon which they based most of their work, which is to some extent a regular imperative sequential language that has added constructs which introduce the capability for concurrency. This difference is also made very visible by their \textit{Proof by Control Flow} method, which implies that there is a distinct order present in the execution. Another big difference is the main focus of the projects. The aim for creating safety proofs was shared, but their other target, liveness proofs were not among our top priorities (although the fixed point property among our results can be related to it), rather we concentrated more on the formalization of general theorems as well as confirming adherence to specification, which is not included in their work. Further differences can be found by observing that the methods they utilize are in closer relation to operational semantics, while our formalization describes behavior in a manner more similar to denotational semantics. Also, some of the proofs presented in that paper are not completely constructive, some properties are only checked by functions essentially returning Boolean results, thus no so-called witness can be used for explaining or reasoning about the results, while the results that are presented in this current paper aim to all be constructive. They also did not implement every little detail included in their proofs, some steps include the usage of postulated properties, which are either relying on paper-based proofs or intuition. Our system is fully self-contained and is built from the ground up in a way meant not to include any external dependency. Their work was related to and part of it was further expanded in \cite{Johan2018ProofCF}.

\section{Previous works in Isabelle/HOL}
Another paper\cite{Complx-Isabelle} discusses a similar topic, but uses the Isabelle/HOL proof assistant\cite{nipkow2002isabelle} built on the imperative paradigm instead of the type theory based alternatives. Their main subject is a version of the generic SIMPL programming language originally introduced in \cite{simpl-schirmer2006verification}, that they extend in a way to support parallel composition and synchronization through shared-variable concurrency and called it COMPLEX. This still results in a system, which is sequential in its nature and contains concurrent sections. This approach is fitting for their goals, as one of their future aims is the translation of low level C code into COMPLEX for verification of for example concurrent operating system kernels. Their work is inspired by the Hoare-Parallel framework\cite{hoare-parallel-nieto2002verification} which is a formalization built using the Owicki-Gries method\cite{owicki1976axiomatic} in Isabelle/HOL. The Owicki-Gries method extends the verification procedure of sequential programs by introducing the notion of \textit{interference freedom}. It works by first proving each single thread correct on its own and then the atomic instructions of the threads are proven not to interfere with the correctness of each other.

\section{Previous works in Coq}
A case study\cite{coq-concurrent-verification-case-study} shows that there are many advantages to the library based approach, which eliminates some complicated modeling tasks by implementing a generalized version of parallelism instead of aiming straight for the proof of a concrete program. They investigate these properties through the verification procedure of a mail server originally written in Java by rewriting it in a modeling language provided by a library. \cite{coq-mail-server} The development of the Coq library is discussed in \cite{AFFELDT200817}. It contains a modeling language based on $\pi$-calculus
% \cite{pi-calculus-Milner1992ACO}
\cite{MILNER19921}
\cite{MILNER199241}
\cite{sangiorgi2003pi}
(which has been modified to enable the usage of Coq datatypes and control structures), a specification language and a collection of reusable lemmas. In this sense, it is similar to our approach, as these mentioned components are also present among our results. Models formalized in their library are also suitable for extraction into executable OCaml code using the facilities provided by Coq, although it is not fully automatic and requires manual modifications.

\section{Our work}
Our approach is different from these examples in that its main goal is to aid the development of solutions given through the formalized specification language, not necessarily the verification of already existing codebases. The control flow (or more like the lack thereof) is also a big differentiation factor of our model when comparing to other similar systems.

\section{Proof assistant for parallel systems}
In another article\cite{Mauw1991APA}, that is more on the theoretical side, but we still considered relevant, the description of a proof assistant based on the algebra of communicating processes, specifically designed for proofs around parallel systems is given.



% In \cite{proving-parallel-assertions} we can see the application of such methods to a concrete program, several properties of an elementary airline reservation system implemented in a general parallel programming language are verified.

% TODO: min. 2 oldal
