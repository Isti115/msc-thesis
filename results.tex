\chapter{Results}

\section{Formalization}

Since our formalization does not follow the book of the subject exactly, we present the five basic notions we introduced in our version:
\begin{itemize}
    \item Type - Inductive set of possible types of variables in the program.
    \item Variable - Index that can be used to reference parts of the state.
    \item State - A function that maps from the variables to the value sets of their types.
    \item Predicate - Inductively defined assertions.
    \item Instruction - A list of parallelly executed assignments that give certain variables new values by evaluating expressions in the current state.
\end{itemize}

% Semantic brackets macro
\newcommand{\sem}[2]{\llbracket #1 \rrbracket #2}

There are also a few extra semantic operators that give the constructs meaning:
\begin{itemize}
    \item $\sem{\_}{c}$ - Turns predicates into conditions that can be evaluated for a given state. Essentially turns a predicated into a function from states to boolean logic. ($\{true , false\}$) \\
    ($\sem{\_}{c} : Predicate \to State \to Condition$) where $Condition = State \to Bool$

    \item $\sem{\_}{a}$ - Makes a statement from a predicate by turning it into a function from state to type. ($\{\top , \bot\}$) By creating a type, an instance can later be given, proving that the statement and thus the predicate holds in the given state. \\
    ($\sem{\_}{a} : Predicate \to State \to Set$)

    \item $\sem{\_}{i}$ - We also define an additional operator which turns instructions into functions that map from states to states. \\ ($\sem{\_}{i} : Instruction \to State \to State$)
\end{itemize}

The following constructions can be introduced based on them:
\begin{itemize}
    \item Truth set - The truth set of a condition is the set of states in which the logical function evaluates to true ($\lceil P \rceil = \{st : State | P(st) = true\}$).
    \item Implication - One condition implies another ($P \Rightarrow Q$) if its truth set is subset of the others ($\lceil P \rceil \subset \lceil Q \rceil$).
    \item Weakest precondition - The weakest precondition for a given condition with respect to an instruction is the logical function that only evaluates to true for a certain state, if after executing that instruction the condition hold true. $wp(i , P) = P \circ \sem{i}{i})$.
    \item Strongest postcondition - For a given condition and instruction the strongest postcondition gives the logical function that determines after executing the instruction whether it was started from a state that satisfied the original condition.
    $
    sp(i, Q)(st) =
        \left\{
        	\begin{array}{ll}
        		true & \mbox{if } \exists st0 : State : \sem{Q}{st0} = true \land \sem{i}{i}(st0) = st \\
        		false & \mbox{otherwise}
        	\end{array}
        \right.
    $
    
\end{itemize}

To iterate on these, we can add some conditional versions of them:

\begin{itemize}
    \item Conditional Instruction - A conditional instruction is an instruction paired with a condition under which it can be executed. ($(P, i)$)
    \item Conditional Instruction Effect Function - 
    $
    \sem{(P, i)}{ci}(st) = 
    \left\{
        	\begin{array}{ll}
        		\sem{i}{i}(st) & \mbox{if } \sem{P}{c}(st) = true \\
        		st & \mbox{otherwise}
        	\end{array}
        \right.
    $
    
    \item Conditional Weakest Precondition - $cwp(ci , P) = P \circ \sem{ci}{ci}$.
    \item Conditional Strongest Postcondition - \\
    $
    csp(ci, Q)(st) =
        \left\{
        	\begin{array}{ll}
        		true & \mbox{if } \exists \, st0 : State , \sem{Q}{c}(st0) = true \land \sem{ci}{ci}(st0) = st \\
        		false & \mbox{otherwise}
        	\end{array}
        \right.
    $
\end{itemize}

And finally the parallel constructions:

\begin{itemize}
    \item Parallel Program - A pair of an initial conditional instruction ($s_0$) and a set of conditional instructions. ($(s_0, \{s_1, \, s_2, \, \dots , \, s_n\})$)

    \item Parallel Conditional Weakest Precondition - Logical function that only returns true, if all the conditional instructions of a parallel program satisfy the Conditional Weakest Precondition. \\
    $
    pcwp(s , P)(st) = \bigwedge\limits_{s_i \in S} cwp(s_i, P)(st)
    $
    \item Parallel Conditional Strongest Postcondition - \\
    $
    pcsp(s , Q)(st) =
        \left\{
        	\begin{array}{ll}
        		true & \mbox{if } \forall s_i \in s : csp(s_i, Q)(st) \\
        		false & \mbox{otherwise}
        	\end{array}
        \right.
    $
\end{itemize}

Using these functions, the following statements can be created:
\paragraph{Unless:}
$P \rhd_S Q$ means that the condition P either stays satisfied, or Q becomes true.
% $P \land \neg Q \Rightarrow \mbox{PCWP}(S, P \lor Q)$
% $P \land \neg Q \Rightarrow \mbox{pcwp}(S, P \lor Q)$

\begin{equation}
    \label{eq:unless}
    \infer{P \rhd_S Q}{P \land \neg Q \Rightarrow pcwp(S, P \lor Q)}
\end{equation}

\paragraph{Progress:}
$P \rightarrowtail_S Q$ means that there is at least one conditional instruction in the program through which we can move from a state which satisfies $P$ but not $Q$ to a state that satisfies $Q$.

\begin{equation}
    \label{eq:progress}
    \infer{P \rightarrowtail_S Q}{\exists s_i \in S : P \land \neg Q \Rightarrow pcwp(s_i, Q)}
\end{equation}

\paragraph{Ensures:}
$P \mapsto_S Q$ means that we can only leave the truth set of $P$ through $Q$ and there exists a conditional instruction through which this can actually happen. (And due to the impartial scheduling, see Definition \ref{def:impartial-scheduling}, it will eventually be executed, so being in the truth set of $P$ essentially ensures that we will step into the truth set of $Q$ in the future.)

\begin{equation}
    \label{eq:ensures}
    \infer{P \mapsto_S Q}{P \rhd_S Q & P \rightarrowtail_S Q}
\end{equation}

\paragraph{Inevitable:}
$P \hookrightarrow_S Q$ is the transitive disjunctive closure of $P \mapsto_S Q$, meaning that if we ever step into the truth set of $P$, we will inevitably have to reach a state in the truth set of $Q$, even if through numerous intermediate steps.

\begin{equation}
    \label{eq:leadsto-fromensures}
    \infer{P \hookrightarrow_S Q}{P \mapsto_S Q}
\end{equation}
\begin{equation}
    \label{eq:leadsto-transitivity}
    \infer{P \hookrightarrow_S R}{P \hookrightarrow_S Q & Q \hookrightarrow_S R}
\end{equation}
\begin{equation}
    \label{eq:leadsto-disjunctivity}
    \infer{P \lor Q \hookrightarrow_S R}{P \hookrightarrow_S R & Q \hookrightarrow_S R}
\end{equation}

\paragraph{Invariant:}
A $P$ predicate is invariant in an $S$ program with the $Q$ initial predicate if $Q$ implies $P$, so it must be true at the beginning, and being in the truth set of $P$ guarantees that we will forever stay there. \\
$Invariant_S(P, Q) = (csp(S, Q) \Rrightarrow \sem{P}{a} \, \land \, P \Rightarrow pcwp(S, P))$

\paragraph{Fixed point:}
We call a certain state ($st$) a fixpoint of a program, if no conditional instruction can further change the values of variables, which means that execution can be halted. \\
$st \in fixpoint(S) = \forall s_i \in S, (\sem{s_i}{ci}(st) = st)$ (also denoted: $\varphi(S)$)


\subsection{Compositions}

\subsubsection{Union}

\subsection{Programs}
\subsection{Statements}
\subsection{Constructions}

\section{Proofs}

There were two kinds of statements that that we could prove in our system. First, there were general theorems, which are true independently and then there is the correctness of certain specific programs, by which we mean the adherence to their specification.

\subsection{Theorems}

\subsubsection{Reflexivity of $\hookrightarrow$}

\subsubsection{PSP}

The most complicated theorem we prove was the theorem of "PSP" (see equation \ref{eq:psp}), meaning "Progress-Safety-Progress" (introduced in this form in \cite{Chandy1988ParallelPD}), which states that if from a set of starting points $P$ a program must eventually reach a set of result states $Q$ and the truth set of a given predicate $R$ cannot be left without entering $B$ than in case we begin execution from a shared point of $P$ and $R$ we will either get to a result ($Q$) while staying in $R$ or enter an error state, $B$. We prove several other helpful lemmas first, that facilitated the construction of the bigger proof later.

\begin{equation}
    \label{eq:psp}
    \infer{P \land R \hookrightarrow_S (Q \land R) \lor B}{P \hookrightarrow_S Q & R \rhd_S B}
\end{equation}

For the construction of this proof we used structural induction. We divided the goal into three parts based on how $P \hookrightarrow_S Q$ was constructed (from an Ensures statement, by the rule of transitivity or distributivity). The first goal is then solved by proving that equation \ref{eq:psp-ensures} holds and then constructing the goal through that.

\begin{equation}
    \label{eq:psp-ensures}
    \infer{P \land R \mapsto_S (Q \land R) \lor B}{P \mapsto_S Q & R \rhd_S B}
\end{equation}

The second and third subgoals can be solved by recursively applying the theorem.

\subsection{Correctness}

We implemented a bubble sort algorithm in the language, but were so far only able to prove a few properties of it, not the full correctness yet.

% We set out to implement bubble sort, which we achieved, but until now we only
We managed to prove that if the first element of the array is one, it can later only change to zero.

\begin{equation}
    \label{eq:bubble-proof-1}
    a[0] = 1 \rhd_{BubbleSort_n} a[0] = 0
\end{equation}
Where BubbleSort is defined as it can be seen in \cite{hz-orsi} and \cite{hz-article}.
% \begin{equation}
% \begin{multlined}
\begin{align}
\begin{split}
    BubbleSort_n = ( & \\
      & (TRUE \:,\: SKIP), \\
      & \{ \, ( \, (a[i] > a[i+1])\:,\:(a[i],a[i+1]:= a[i+1],a[i] \, ) \; | \; i \in \{1,\dots,n-1\} \, \} \\
    ) &
\end{split}
\end{align}
% \end{multlined}
% \end{equation}